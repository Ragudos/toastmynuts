var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/toaster.ts
var TOAST_DEFAULT_DURATION = 1e4;
var TOAST_CONTAINER_ID = "__toastmynuts__";
var TOAST_WRAPPER_ID = "__toastmynuts__wrapper";
var TOAST_CLASS = "__toastmynuts__toast";
var TOAST_MESSAGE_CLASS = "__toastmynuts__message";
var TOAST_CLOSE_BTN_CLASS = "__toastmynuts__close-btn";
var TOAST_TYPE_ATTR_NAME = "data-toast-type";
var TOAST_DEFAULT_POSITION = { x: "middle", y: "top" };
var TOAST_MAX_VISIBLE_TOASTS = 3;
var TOAST_TYPE_ICONS = {
  neutral: "",
  promise: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" width="24" height="24" style="shape-rendering: auto; display: block; background: transparent;" xmlns:xlink="http://www.w3.org/1999/xlink"><g><circle cx="50" cy="50" fill="none" stroke="currentColor" stroke-width="8" r="35" stroke-dasharray="164.93361431346415 56.97787143782138"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle><g></g></g><!-- [ldio] generated by https://loading.io --></svg>`,
  info: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm8.706-1.442c1.146-.573 2.437.463 2.126 1.706l-.709 2.836.042-.02a.75.75 0 0 1 .67 1.34l-.04.022c-1.147.573-2.438-.463-2.127-1.706l.71-2.836-.042.02a.75.75 0 1 1-.671-1.34l.041-.022ZM12 9a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z" clip-rule="evenodd" /></svg>`,
  error: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75Zm0 8.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z" clip-rule="evenodd" /></svg>`,
  success: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm13.36-1.814a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z" clip-rule="evenodd" /></svg>`,
  warning: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path fill-rule="evenodd" d="M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75Zm0 8.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z" clip-rule="evenodd" /></svg>`
};
function genRandomId() {
  return Math.random().toString(16).slice(2);
}
__name(genRandomId, "genRandomId");
function getDir() {
  const dirAttr = document.documentElement.getAttribute("dir");
  if (dirAttr !== "rtl" && dirAttr !== "ltr") {
    return window.getComputedStyle(document.documentElement).direction;
  }
  return dirAttr;
}
__name(getDir, "getDir");
var Toaster = class _Toaster {
  static {
    __name(this, "Toaster");
  }
  static _instance;
  static _toastDuration;
  static _config;
  /**
   * We store the directionality of the document
   * if it's not specified in the config
   * so we don't repeatedly call getComputedStyle
   */
  static _defaultDir;
  _toasts;
  /**
   * To avoid a race condition for moving toasts upwards when removing a toast,
   * where in the loop, they'd have the same reference to the toast array before the
   * previous toasts were removed (they are still in an exit animation and yet to be removed),
   * we add them to a toBeRemovedArray so we can remove them from the main toast array
   */
  _toastToBeRemoved;
  _toastContainerAbortControllers;
  constructor() {
    this._toasts = [];
    this._toastToBeRemoved = [];
    this._toastContainerAbortControllers = [];
  }
  /**
   * @throws {Error} If maxVisibleToasts is < 1 or toastDuration is < 100ms
   */
  static getInstance(config) {
    if (!_Toaster._instance) {
      _Toaster._instance = new _Toaster();
      _Toaster._config = config;
      _Toaster._toastDuration = config?.toastDuration ?? TOAST_DEFAULT_DURATION;
      if (!_Toaster._config?.dir) {
        _Toaster._defaultDir = getDir();
      }
      if (config?.maxVisibleToasts !== void 0 && config.maxVisibleToasts < 1) {
        throw new Error(
          "[ToastMyNuts] maxVisibleToasts must be a positive number"
        );
      }
      if (config?.toastDuration !== void 0 && config.toastDuration < 100) {
        throw new Error(
          "[ToastMyNuts] toastDuration must be at least 100 milliseconds"
        );
      }
    }
    return _Toaster._instance;
  }
  /**
   * @param param The position of the toast container
   *
   * @description Sets the position of the toast container,
   * which in turn changes the position of the toasts.
   */
  setPosition({ x, y }) {
    const toastContainer = document.getElementById(TOAST_CONTAINER_ID);
    if (toastContainer) {
      toastContainer.setAttribute("data-position-x", x);
      toastContainer.setAttribute("data-position-y", y);
    }
    if (!_Toaster._config) {
      _Toaster._config = {
        position: { x, y }
      };
    } else {
      _Toaster._config.position = { x, y };
    }
  }
  /**
   * @param isStackable
   *
   * @description Whether or not to stack toasts. Take note
   * that this will only take into effect if all toasts are empty,
   * since we are attaching listeners to the supposed toast container which
   * is created when the first toast is added.
   */
  setIsStackable(isStackable) {
    if (!_Toaster._config) {
      _Toaster._config = {
        stackable: isStackable
      };
    } else {
      _Toaster._config.stackable = isStackable;
    }
  }
  /**
   * @throws {[string, K]} If the promise fails,
   * the promise toast will be updated to an error toast.
   */
  addPromiseToast(loadingMessage, successMessageStringOrCb, errorMessageStringOrCb, asyncOperation, options) {
    const toastId = this.addToast(loadingMessage, "promise", options);
    return new Promise((resolve, reject) => {
      let isSuccess = false;
      let data;
      let err;
      (typeof asyncOperation === "function" ? asyncOperation() : asyncOperation).then((value) => {
        isSuccess = true;
        data = value;
        resolve([toastId, value]);
      }).catch((error) => {
        isSuccess = false;
        err = error;
        reject([toastId, error]);
      }).finally(() => {
        let toast;
        let toastIdx;
        for (let i = 0; i < this._toasts.length; ++i) {
          if (this._toasts[i]._id === toastId) {
            toast = this._toasts[i];
            toastIdx = i;
          }
        }
        if (!toast) {
          throw new Error(
            "[ToastMyNuts] Could not find toast with ID " + toastId + " virtually"
          );
        }
        const toastContainer = document.getElementById(TOAST_CONTAINER_ID);
        if (!toastContainer) {
          throw new Error(
            "[ToastMyNuts] Could not find toast container with ID " + TOAST_CONTAINER_ID
          );
        }
        const toastElement = document.getElementById(toastId);
        if (!toastElement) {
          throw new Error(
            "[ToastMyNuts] Could not find toast with ID " + toastId + " in the DOM"
          );
        }
        const toastRelativeContainer = toastElement.querySelector("div");
        if (!toastRelativeContainer) {
          throw new Error(
            "[ToastMyNuts] Could not find toast relative container"
          );
        }
        const toastMessageContainer = toastRelativeContainer.querySelector(
          "." + TOAST_MESSAGE_CLASS
        );
        if (!toastMessageContainer) {
          throw new Error(
            "[ToastMyNuts] Could not find toast message container"
          );
        }
        let iconContainer;
        const existingIconContainer = toastElement.querySelector(
          ".__toastmynuts__icon"
        );
        if (!existingIconContainer) {
          iconContainer = document.createElement("div");
          iconContainer.classList.add("__toastmynuts__icon");
        } else {
          existingIconContainer.innerHTML = "";
          iconContainer = existingIconContainer;
        }
        if (isSuccess) {
          toast._type = "success";
          toastElement.setAttribute(
            TOAST_TYPE_ATTR_NAME,
            "success"
          );
          toastMessageContainer.textContent = typeof successMessageStringOrCb === "function" ? successMessageStringOrCb(data) : successMessageStringOrCb;
          iconContainer.innerHTML = TOAST_TYPE_ICONS.success;
        } else {
          toast._type = "error";
          toastElement.setAttribute(
            TOAST_TYPE_ATTR_NAME,
            "error"
          );
          toastMessageContainer.textContent = typeof errorMessageStringOrCb === "function" ? errorMessageStringOrCb(err) : errorMessageStringOrCb;
          iconContainer.innerHTML = TOAST_TYPE_ICONS.error;
        }
        const [closeBtn, closeBtnAbortController] = this._createCloseBtn(toast._id);
        const closeOnSwipe = options?.closeOnSwipe || _Toaster._config?.closeOnSwipe;
        toast._controllers.push(closeBtnAbortController);
        if (closeOnSwipe === true || closeOnSwipe === void 0) {
          toast._controllers.push(
            this._attachSwipeListenersToToast(toastElement)
          );
        }
        const isExpanded = toastContainer.getAttribute("data-expanded") === "true";
        if (!isExpanded) {
          toast._timeout = setTimeout(() => {
            this.removeToast(toastId);
          }, _Toaster._toastDuration);
        }
        toastRelativeContainer.prepend(iconContainer);
        toastRelativeContainer.appendChild(closeBtn);
        const origFrontToastHeight = toastContainer.style.getPropertyValue(
          "--_front-toast-height"
        );
        toastElement.style.removeProperty("--_initial-height");
        toastContainer.style.removeProperty(
          "--_front-toast-height"
        );
        const origHeight = toastElement.style.height;
        toastElement.style.height = "auto";
        const packedHeight = toastElement.getBoundingClientRect().height;
        const packedHeightString = `${packedHeight}px`;
        toastElement.style.height = origHeight;
        if (toastElement.getAttribute("data-front-toast") === "true") {
          toastContainer.style.setProperty(
            "--_front-toast-height",
            packedHeightString
          );
        } else {
          toastContainer.style.setProperty(
            "--_front-toast-height",
            origFrontToastHeight
          );
        }
        toastElement.style.setProperty(
          "--_initial-height",
          packedHeightString
        );
        this._moveToastsDown(packedHeight, true);
      });
    });
  }
  addToast(message, type = "neutral", options) {
    const [toastContainer, _] = this._getOrCreateToastContainer();
    const toastId = genRandomId();
    const [toastElement, toastListenersAbortController] = this._createToastElement(toastId, type, options);
    const toastRelativeContainer = document.createElement("div");
    const messageElement = this._createMessageElement(message);
    const controllersArray = [toastListenersAbortController];
    let closeBtn;
    let timeout;
    if (type !== "promise") {
      timeout = setTimeout(() => {
        this.removeToast(toastId);
      }, _Toaster._toastDuration);
      const [closeBtnItem, closeBtnAbortControllerItem] = this._createCloseBtn(toastId);
      closeBtn = closeBtnItem;
      controllersArray.push(closeBtnAbortControllerItem);
    }
    if (type !== "neutral") {
      const iconContainer = document.createElement("div");
      iconContainer.innerHTML = TOAST_TYPE_ICONS[type];
      iconContainer.classList.add("__toastmynuts__icon");
      toastRelativeContainer.appendChild(iconContainer);
    }
    toastRelativeContainer.appendChild(messageElement);
    if (closeBtn) {
      toastRelativeContainer.appendChild(closeBtn);
    }
    toastElement.appendChild(toastRelativeContainer);
    toastContainer.prepend(toastElement);
    const originalHeight = toastElement.style.height;
    toastElement.style.height = "auto";
    const packedHeight = toastElement.getBoundingClientRect().height;
    const packedHeightString = `${packedHeight}px`;
    toastElement.style.height = originalHeight;
    toastContainer.style.setProperty(
      "--_front-toast-height",
      packedHeightString
    );
    toastElement.style.setProperty("--_initial-height", packedHeightString);
    toastElement.removeAttribute("data-toast-state");
    this._moveToastsDown(packedHeight);
    const dateNow = Date.now();
    this._toasts.push({
      _message: message,
      _type: type,
      _controllers: controllersArray,
      _timeout: timeout,
      _duration: _Toaster._toastDuration,
      _id: toastId,
      _created_on: dateNow,
      _timeout_created_on: options?.closeOnSwipe ? dateNow : void 0
    });
    return toastId;
  }
  removeToast(toastId) {
    let toast;
    let toastIdx;
    for (let i = 0; i < this._toasts.length; ++i) {
      if (this._toasts[i]._id === toastId) {
        toast = this._toasts[i];
        toastIdx = i;
      }
    }
    if (!toast || toastIdx === void 0) {
      throw new Error(
        "[ToastMyNuts] Could not find toast with ID " + toastId + " virtually"
      );
    }
    if (toast._type === "promise") {
      return;
    }
    const toastElement = document.getElementById(toast._id);
    if (!toastElement) {
      throw new Error(
        "[ToastMyNuts] Could not find toast with ID " + toastId + " in the DOM"
      );
    }
    const isExiting = toastElement.getAttribute("data-toast-state") === "closing";
    if (isExiting) {
      return;
    }
    while (toast._controllers.length !== 0) {
      toast._controllers.pop()?.abort();
    }
    const isHidden = toastElement.getAttribute("data-toast-state") === "hidden";
    if (toast._timeout !== void 0) {
      clearTimeout(toast._timeout);
    }
    if (isHidden) {
      this._removeToastPermanently(toastId, true);
      this._toasts.splice(toastIdx, 1);
      this._changeToastsZindex(toastIdx);
      return;
    }
    toastElement.setAttribute("data-toast-state", "closing");
    const toastElementTransitionDuration = parseFloat(
      getComputedStyle(toastElement).transitionDuration
    );
    this._moveToastsUp(toastIdx);
    this._toastToBeRemoved.push(toast);
    this._toasts.splice(toastIdx, 1);
    this._changeToastsZindex(toastIdx);
    setTimeout(() => {
      this._removeToastPermanently(toastId, false);
    }, toastElementTransitionDuration * 1e3);
  }
  /**
   * Whether our toast did not have an exit animation
   */
  _removeToastPermanently(toastId, isRemovedInstantly) {
    let toast;
    let toastIdx;
    if (isRemovedInstantly) {
      for (let i = 0; i < this._toasts.length; ++i) {
        if (this._toasts[i]._id === toastId) {
          toast = this._toasts[i];
          toastIdx = i;
        }
      }
    } else {
      for (let i = 0; i < this._toastToBeRemoved.length; ++i) {
        if (this._toastToBeRemoved[i]._id === toastId) {
          toast = this._toastToBeRemoved[i];
          toastIdx = i;
        }
      }
    }
    if (!toast) {
      throw new Error(
        "[ToastMyNuts] Could not find toast with ID " + toastId + " virtually"
      );
    }
    const toastElement = document.getElementById(toast._id);
    toastElement?.remove();
    if (!isRemovedInstantly && toastIdx !== void 0) {
      this._toastToBeRemoved.splice(toastIdx, 1);
    }
    if (this._toasts.length === 0) {
      const toastWrapper = document.getElementById(TOAST_WRAPPER_ID);
      while (this._toastContainerAbortControllers.length !== 0) {
        this._toastContainerAbortControllers.pop()?.abort();
      }
      toastWrapper?.remove();
    }
  }
  /**
   * Removes all timeouts in the toasts array
   * and for each toast, changed their duration to
   * the remaining time before they get removed.
   * Used when expanding a stacked toast.
   */
  _removeTimeoutOfToasts() {
    const dateNow = Date.now();
    for (let i = 0; i < this._toasts.length; ++i) {
      const toast = this._toasts[i];
      if (toast._timeout) {
        const remainingTime = toast._timeout_created_on !== void 0 ? toast._duration - (dateNow - toast._timeout_created_on) : toast._duration;
        if (remainingTime <= 0) {
          continue;
        }
        clearTimeout(toast._timeout);
        toast._duration = remainingTime;
        toast._timeout = void 0;
      }
    }
  }
  /**
   * Adds all timeouts in the toasts array.
   * Used when stacking an expanded stacked toast.
   */
  _addTimeoutToToasts() {
    const dateNow = Date.now();
    for (let i = 0; i < this._toasts.length; ++i) {
      const toast = this._toasts[i];
      if (toast._type === "promise") {
        continue;
      }
      if (!toast._timeout) {
        toast._timeout_created_on = dateNow;
        toast._timeout = setTimeout(() => {
          this.removeToast(toast._id);
        }, toast._duration);
      }
    }
  }
  /**
   * @param toastIdx The starting point from where we move the z indices of its sibling toasts.
   */
  _changeToastsZindex(toastIdx) {
    for (let i = toastIdx; i < this._toasts.length; ++i) {
      const toast = this._toasts[i];
      if (!toast) {
        continue;
      }
      const toastElement = document.getElementById(toast._id);
      if (!toastElement) {
        throw new Error(
          "[ToastMyNuts] Could not find toast with ID " + toast._id + " in the DOM"
        );
      }
      toastElement.style.setProperty("--_z-idx", i.toString());
    }
  }
  /**
   * Used when a toast is removed
   */
  _moveToastsUp(start) {
    const maxVisibleToasts = _Toaster._config?.maxVisibleToasts ?? TOAST_MAX_VISIBLE_TOASTS;
    for (let i = 0; i < start; ++i) {
      const toast = this._toasts[i];
      if (!toast) {
        throw new Error(
          "[ToastMyNuts] Could not find toast with index " + i + " virtually"
        );
      }
      const toastElement = document.getElementById(toast._id);
      if (!toastElement) {
        throw new Error(
          "[ToastMyNuts] Could not find toast with ID " + toast._id + " in the DOM"
        );
      }
      let heightOffset = 0;
      for (let j = i + 1; j < this._toasts.length; ++j) {
        if (j === start) {
          continue;
        }
        const toast2 = this._toasts[j];
        const toastElement2 = document.getElementById(toast2._id);
        if (!toastElement2) {
          throw new Error(
            "[ToastMyNuts] Could not find toast with ID " + toast2._id + " in the DOM"
          );
        }
        const initialHeight = parseFloat(
          toastElement2.style.getPropertyValue("--_initial-height")
        );
        heightOffset += initialHeight;
      }
      toastElement.style.setProperty(
        "--_height-offset",
        `${heightOffset}px`
      );
      const newLastToastIdx = this._toasts.length - 2;
      toastElement.style.setProperty(
        "--_idx",
        (newLastToastIdx - i).toString()
      );
      if (i === newLastToastIdx) {
        const toastContainer = document.getElementById(TOAST_CONTAINER_ID);
        if (!toastContainer) {
          throw new Error(
            "[ToastMyNuts] Could not find toast container with ID " + TOAST_CONTAINER_ID
          );
        }
        const packedHeightString = toastElement.style.getPropertyValue("--_initial-height");
        toastContainer.style.setProperty(
          "--_front-toast-height",
          packedHeightString
        );
        toastElement.setAttribute("data-front-toast", "true");
      }
      if (this._toasts.length - i <= maxVisibleToasts + 1) {
        if (toastElement.getAttribute("data-toast-state") === "hidden") {
          toastElement.removeAttribute("data-toast-state");
          toastElement.removeAttribute("aria-hidden");
        }
      }
    }
  }
  /**
   * Used when a new toast is added
   */
  _moveToastsDown(baseHeightOffset, isFromPromise) {
    const maxVisibleToasts = _Toaster._config?.maxVisibleToasts ?? TOAST_MAX_VISIBLE_TOASTS;
    for (let i = 0; i < this._toasts.length; ++i) {
      const toast = this._toasts[i];
      const toastElement = document.getElementById(toast._id);
      if (!toastElement) {
        throw new Error(
          "[ToastMyNuts] Could not find toast with ID " + toast._id
        );
      }
      let heightOffset = isFromPromise ? 0 : baseHeightOffset;
      for (let j = i + 1; j < this._toasts.length; ++j) {
        const toast2 = this._toasts[j];
        const toastElement2 = document.getElementById(toast2._id);
        if (!toastElement2) {
          throw new Error(
            "[ToastMyNuts] Could not find toast with ID " + toast2._id
          );
        }
        let initialHeight = parseFloat(
          toastElement2.style.getPropertyValue("--_initial-height")
        );
        heightOffset += initialHeight;
      }
      toastElement.style.setProperty(
        "--_height-offset",
        `${heightOffset}px`
      );
      if (!isFromPromise) {
        toastElement.style.setProperty(
          "--_idx",
          (this._toasts.length - i).toString()
        );
        toastElement.removeAttribute("data-front-toast");
        if (this._toasts.length - i >= maxVisibleToasts) {
          if (toastElement.getAttribute("data-toast-state") !== "closing") {
            toastElement.setAttribute("data-toast-state", "hidden");
            toastElement.setAttribute("aria-hidden", "true");
          }
        }
      }
    }
  }
  _getOrCreateToastContainer() {
    const toastContainer = document.getElementById(TOAST_CONTAINER_ID);
    if (!toastContainer) {
      const toastWrapper = document.createElement("div");
      const abortController = new AbortController();
      toastWrapper.id = TOAST_WRAPPER_ID;
      toastWrapper.setAttribute("aria-label", "Notifications (Alt + T)");
      toastWrapper.setAttribute("tabindex", "-1");
      const toastContainer2 = document.createElement("ol");
      toastContainer2.id = TOAST_CONTAINER_ID;
      const isStackable = _Toaster._config?.stackable === true || _Toaster._config?.stackable === void 0;
      toastContainer2.setAttribute(
        "data-position-x",
        _Toaster._config?.position?.x || TOAST_DEFAULT_POSITION.x
      );
      toastContainer2.setAttribute(
        "data-position-y",
        _Toaster._config?.position?.y || TOAST_DEFAULT_POSITION.y
      );
      toastContainer2.setAttribute(
        "data-stackable",
        isStackable ? "true" : "false"
      );
      toastContainer2.setAttribute(
        "data-expanded",
        isStackable ? "false" : "true"
      );
      if (_Toaster._config?.theme === "dark" || _Toaster._config?.theme === "light") {
        toastContainer2.setAttribute(
          "data-theme",
          _Toaster._config.theme
        );
      }
      toastContainer2.addEventListener(
        "pointerenter",
        () => {
          if (isStackable) {
            if (toastContainer2.getAttribute(
              "data-did-toggle-expansion"
            ) === "true") {
              return;
            }
            toastContainer2.setAttribute("data-expanded", "true");
            toastContainer2.removeAttribute("data-should-stack");
          }
          this._removeTimeoutOfToasts();
        },
        { passive: true, signal: abortController.signal }
      );
      toastContainer2.addEventListener(
        "pointerleave",
        () => {
          if (isStackable) {
            if (toastContainer2.getAttribute(
              "data-did-toggle-expansion"
            ) === "true") {
              return;
            }
            const children = toastContainer2.children;
            for (let i = 0; i < children.length; ++i) {
              if (children[i].getAttribute("data-is-swiping") === "true") {
                toastContainer2.setAttribute(
                  "data-should-stack",
                  "true"
                );
                return;
              }
            }
            toastContainer2.setAttribute("data-expanded", "false");
          }
          this._addTimeoutToToasts();
        },
        { passive: true, signal: abortController.signal }
      );
      if (isStackable) {
        window.addEventListener(
          "keydown",
          (e) => {
            if (e.altKey && e.code === "KeyT") {
              if (toastContainer2.getAttribute(
                "data-did-toggle-expansion"
              ) === "true") {
                return;
              }
              const shouldExpand = toastContainer2.getAttribute("data-expanded") === "false";
              toastContainer2.setAttribute(
                "data-expanded",
                shouldExpand ? "true" : "false"
              );
              toastContainer2.setAttribute(
                "data-did-toggle-expansion",
                "true"
              );
              if (shouldExpand) {
                this._removeTimeoutOfToasts();
              } else {
                this._addTimeoutToToasts();
              }
            }
          },
          { passive: true, signal: abortController.signal }
        );
        window.addEventListener(
          "keyup",
          (e) => {
            if (e.code === "KeyT") {
              toastContainer2.setAttribute(
                "data-did-toggle-expansion",
                "false"
              );
            }
          },
          { passive: true, signal: abortController.signal }
        );
      }
      toastWrapper.appendChild(toastContainer2);
      document.body.appendChild(toastWrapper);
      this._toastContainerAbortControllers.push(abortController);
      return [toastContainer2, abortController];
    }
    if (!(toastContainer instanceof HTMLOListElement)) {
      throw new Error(
        "[ToastMyNuts] Colliding ID " + TOAST_CONTAINER_ID + "."
      );
    }
    return [toastContainer, void 0];
  }
  _createMessageElement(message) {
    const messageElement = document.createElement("div");
    messageElement.textContent = message;
    messageElement.classList.add(TOAST_MESSAGE_CLASS);
    return messageElement;
  }
  _createToastElement(toastId, type, options) {
    const toastElement = document.createElement("li");
    toastElement.id = toastId;
    toastElement.classList.add(TOAST_CLASS);
    toastElement.style.setProperty("--_idx", "0");
    toastElement.style.setProperty(
      "--_z-idx",
      this._toasts.length.toString()
    );
    toastElement.setAttribute(TOAST_TYPE_ATTR_NAME, type);
    toastElement.setAttribute("data-toast-state", "entering");
    toastElement.setAttribute("aria-live", "polite");
    toastElement.setAttribute("aria-atomic", "true");
    toastElement.setAttribute("data-front-toast", "true");
    toastElement.setAttribute(
      "dir",
      options?.dir || _Toaster._config?.dir || _Toaster._defaultDir
    );
    if (options?.theme) {
      toastElement.setAttribute("data-theme", options.theme);
    }
    if (options?.richColors === true || _Toaster._config?.richColors) {
      toastElement.setAttribute("data-rich-colors", "true");
    }
    let closeOnSwipe = options?.closeOnSwipe === void 0 ? _Toaster._config?.closeOnSwipe : options.closeOnSwipe;
    let listenerAbortController;
    if ((closeOnSwipe === true || closeOnSwipe === void 0) && type !== "promise") {
      listenerAbortController = this._attachSwipeListenersToToast(toastElement);
    }
    return [toastElement, listenerAbortController];
  }
  /**
   * Only call this once on a toast element.
   */
  _attachSwipeListenersToToast(toastElement) {
    const listenerAbortController = new AbortController();
    toastElement.addEventListener(
      "pointerdown",
      (evt) => {
        evt.target.setPointerCapture(evt.pointerId);
        toastElement.setAttribute("data-is-swiping", "true");
        toastElement.setAttribute(
          "data-dragstart-time",
          Date.now().toString()
        );
        const originalPosition = evt.screenY;
        toastElement.style.setProperty(
          "--_original-position",
          originalPosition.toString()
        );
      },
      { signal: listenerAbortController.signal, passive: true }
    );
    window.addEventListener(
      "pointerup",
      (_evt) => {
        const swipeOffset = parseFloat(
          toastElement.style.getPropertyValue("--_swipe-offset")
        );
        const absValue = Math.abs(swipeOffset);
        const dragStartTime = parseFloat(
          toastElement.getAttribute("data-dragstart-time") ?? "0"
        );
        const timeTaken = Date.now() - dragStartTime;
        const velocity = Math.abs(swipeOffset) / timeTaken;
        toastElement.setAttribute("data-is-swiping", "false");
        if (absValue >= 10 || velocity >= 0.5) {
          toastElement.setAttribute("data-exit-swipe", "true");
          this.removeToast(toastElement.id);
        } else {
          toastElement.style.setProperty("--_swipe-offset", "0");
          toastElement.style.opacity = "";
          toastElement.style.removeProperty("--_original-position");
          toastElement.removeAttribute("data-dragstart-time");
        }
        const toastContainer = document.getElementById(TOAST_CONTAINER_ID);
        if (!toastContainer) {
          throw new Error(
            "[ToastMyNuts] Could not find toast container with ID " + TOAST_CONTAINER_ID
          );
        }
        if (toastContainer.getAttribute("data-should-stack") === "true") {
          toastContainer.setAttribute("data-should-stack", "false");
          toastContainer.setAttribute("data-expanded", "false");
          this._addTimeoutToToasts();
        }
      },
      { signal: listenerAbortController.signal, passive: true }
    );
    window.addEventListener(
      "pointermove",
      (evt) => {
        const isSwiping = toastElement.getAttribute("data-is-swiping") === "true";
        if (!isSwiping) {
          return;
        }
        const toastContainer = document.getElementById(TOAST_CONTAINER_ID);
        if (!toastContainer) {
          throw new Error(
            "[ToastMyNuts] Could not find toast container with ID " + TOAST_CONTAINER_ID
          );
        }
        const verticalPosition = toastContainer.getAttribute("data-position-y");
        const isTop = verticalPosition === "top";
        const isBottom = verticalPosition === "bottom";
        const originalPosition = parseFloat(
          toastElement.style.getPropertyValue("--_original-position")
        );
        const swipeOffset = originalPosition - evt.screenY;
        if (isTop && swipeOffset < 0 || isBottom && swipeOffset > 0) {
          return;
        } else if (!isTop && !isBottom) {
          throw new Error(
            "[ToastMyNuts] Invalid vertical position " + verticalPosition
          );
        }
        const opacity = Math.max(
          1 - Math.abs(swipeOffset) / 35,
          0.25
        ).toFixed(2);
        toastElement.style.opacity = opacity;
        toastElement.style.setProperty(
          "--_swipe-offset",
          swipeOffset.toString()
        );
      },
      { signal: listenerAbortController.signal, passive: true }
    );
    return listenerAbortController;
  }
  _createCloseBtn(toastId) {
    const closeBtnAbortController = new AbortController();
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.setAttribute("aria-label", "Close notification");
    closeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="w-4 h-4"><path d="M5.28 4.22a.75.75 0 0 0-1.06 1.06L6.94 8l-2.72 2.72a.75.75 0 1 0 1.06 1.06L8 9.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L9.06 8l2.72-2.72a.75.75 0 0 0-1.06-1.06L8 6.94 5.28 4.22Z" /></svg>`;
    closeBtn.classList.add(TOAST_CLOSE_BTN_CLASS);
    closeBtn.addEventListener(
      "click",
      () => {
        this.removeToast(toastId);
      },
      { signal: closeBtnAbortController.signal, passive: true }
    );
    return [closeBtn, closeBtnAbortController];
  }
};

// src/index.esm.ts
var functions;
function initializeToast(config) {
  if (functions) {
    return functions;
  }
  const toaster = Toaster.getInstance(config);
  function defaultToast(message, options) {
    return toaster.addToast(message, "neutral", options);
  }
  __name(defaultToast, "defaultToast");
  function successToast(message, options) {
    return toaster.addToast(message, "success", options);
  }
  __name(successToast, "successToast");
  function errorToast(message, options) {
    return toaster.addToast(message, "error", options);
  }
  __name(errorToast, "errorToast");
  function warningToast(message, options) {
    return toaster.addToast(message, "warning", options);
  }
  __name(warningToast, "warningToast");
  function infoToast(message, options) {
    return toaster.addToast(message, "info", options);
  }
  __name(infoToast, "infoToast");
  functions = Object.assign(defaultToast, {
    setPosition: toaster.setPosition.bind(toaster),
    setIsStackable: toaster.setIsStackable.bind(toaster),
    remove: toaster.removeToast.bind(toaster),
    success: successToast,
    error: errorToast,
    warning: warningToast,
    info: infoToast,
    promise: toaster.addPromiseToast.bind(toaster)
  });
  return functions;
}
__name(initializeToast, "initializeToast");
export {
  initializeToast
};
//# sourceMappingURL=index.esm.js.map
